---
title: "JHipster"
excerpt: "JHipster"
categories: 
  - springboot
tags: 
  - springboot
last_modified_at: 2022-01-10T00:00:00+09:00
toc: true
toc_sticky: true
---

### JHipster 설치 준비

1. **Node.js 설치**: JHipster는 Node.js 기반으로 동작합니다. 따라서, Node.js가 시스템에 설치되어 있지 않다면 먼저 설치해야 합니다.

2. **JHipster CLI 설치**: JHipster를 사용하기 위해서는 JHipster CLI(Command Line Interface)를 설치해야 합니다. 이는 npm을 통해 설치할 수 있습니다.
   ```
   npm install -g generator-jhipster
   ```

### JHipster 프로젝트 생성

1. **프로젝트 폴더 생성 및 이동**: 새로운 JHipster 프로젝트를 위한 디렉토리를 만들고, 해당 디렉토리로 이동합니다.
   ```
   mkdir myProject
   cd myProject
   ```

2. **JHipster 프로젝트 생성**: 프로젝트 디렉토리에서 다음 CLI 명령어를 실행하여 JHipster 프로젝트를 생성합니다.
   ```
   jhipster
   ```

### JHipster 설정

1. **프로젝트 유형 선택**: 애플리케이션 유형(모노리틱 애플리케이션, 마이크로서비스 애플리케이션 등)을 선택합니다.

2. **기술 스택 선택**: 사용할 기술 스택(데이터베이스 유형, 캐시, 인증 메커니즘 등)에 대한 선택을 합니다.

3. **기타 옵션 설정**: 여러 추가 옵션들(테스트 프레임워크, 다국어 지원 등)에 대한 설정을 진행합니다.

### "May JHipster anonymously report usage statistics to improve the tool over time?"

이 단계에서는 JHipster 개발팀이 도구를 시간이 지남에 따라 개선할 수 있도록 익명으로 사용 통계를 보고할 수 있는지 묻습니다. 여기서 "Yes"를 선택하면 사용 통계가 익명으로 전송되며, 이는 JHipster를 개선하는 데 도움이 됩니다. "No"를 선택하면 어떠한 데이터도 전송되지 않습니다. 이는 완전히 자발적인 선택이며, JHipster 사용에 필수적인 요소는 아닙니다.

### JHipster에서는 주로 세 가지 유형의 애플리케이션을 생성할 수 있습니다: Monolithic application, Gateway application, 그리고 Microservice application. 각각의 설정에 대해 설명드리겠습니다.

1. **Monolithic Application (단일 애플리케이션, 간단한 프로젝트에 권장)**
   - 단일 애플리케이션은 클라이언트 사이드 UI, 서버 사이드 애플리케이션, 그리고 데이터베이스가 모두 하나의 애플리케이션으로 패키징되는 구조입니다. 
   - 모든 기능이 하나의 애플리케이션 내에서 구현되므로, 관리 및 배포가 간단하며, 작거나 간단한 프로젝트에 적합합니다.
   - 개발, 테스트, 배포가 비교적 간단하므로 속도와 효율성 측면에서 이점이 있습니다.

2. **Gateway Application (게이트웨이 애플리케이션)**
   - 게이트웨이 애플리케이션은 마이크로서비스 아키텍처에서 클라이언트 요청을 처리하고 내부 마이크로서비스로 라우팅하는 역할을 합니다.
   - 사용자 인증, 로드 밸런싱, 캐싱, SSL 종료 등의 기능을 수행할 수 있습니다.
   - 마이크로서비스 기반의 복잡한 애플리케이션 구조에서 클라이언트 사이드 UI와 백엔드 마이크로서비스 사이의 중간 계층으로 동작합니다.

3. **Microservice Application (마이크로서비스 애플리케이션)**
   - 마이크로서비스 애플리케이션은 애플리케이션의 기능을 작은 서비스로 나누어 개발하는 접근 방식입니다.
   - 각 마이크로서비스는 독립적으로 배포할 수 있고, 서로 다른 프로그래밍 언어로 작성될 수 있으며, 각각의 데이터베이스를 가질 수 있습니다.
   - 복잡한 애플리케이션을 개발하고, 유지보수하며, 확장성을 높이는데 유리합니다. 다만, 마이크로서비스 간의 통신, 데이터 일관성 유지, 서비스 디스커버리 등의 추가적인 관리가 필요합니다.

각 애플리케이션 유형의 선택은 프로젝트의 요구사항, 복잡성, 팀의 경험 및 인프라 구성 등을 고려하여 결정해야 합니다. 

### JHipster 프로젝트 설정 중 테스팅 프레임워크 선택 단계에서는 JUnit 외에도 사용할 수 있는 테스팅 프레임워크를 선택할 수 있습니다. 여기서 언급된 두 가지 옵션, Gatling과 Cucumber에 대해 간단히 설명드리겠습니다.

1. **Gatling**: Gatling은 고성능 부하 테스팅을 위한 오픈소스 툴입니다. 이는 웹 애플리케이션의 스트레스 테스팅과 성능 측정에 사용됩니다. Gatling을 사용하면 실제 사용자가 시스템을 사용하는 것과 유사한 방식으로 시스템에 부하(load)를 생성하고, 그 결과를 분석하여 시스템의 성능을 평가할 수 있습니다. Gatling은 Scala로 작성되었지만, 복잡한 성능 테스트 시나리오를 쉽게 구성할 수 있는 DSL(Domain Specific Language)을 제공합니다.

2. **Cucumber**: Cucumber는 행동 주도 개발(Behavior Driven Development, BDD)에 사용되는 오픈소스 툴입니다. Cucumber를 사용하면 비기술적인 이해관계자(예: 비즈니스 분석가, 제품 매니저)도 이해할 수 있는 언어(Gherkin)로 테스트 사례를 작성할 수 있습니다. 이러한 테스트 사례는 그대로 자동화된 테스트로 사용될 수 있으며, 개발 과정에서 요구사항이 정확히 충족되었는지 확인하는 데 도움을 줍니다.

설정 단계에서 여러분의 프로젝트 요구사항과 팀의 선호도에 따라 적절한 테스팅 프레임워크를 선택할 수 있습니다. 부하 테스트가 중요한 경우 Gatling을, BDD 접근 방식을 선호하거나 비기술적 이해관계자와의 소통이 중요한 경우 Cucumber를 선택할 수 있습니다. 


### JHipster에서 마이크로서비스 아키텍처를 구축할 때 서비스 검색(Service Discovery)은 중요한 역할을 합니다. 서비스 검색 서버를 사용하면 마이크로서비스 간에 서로를 자동으로 찾을 수 있으며, 이는 마이크로서비스가 동적으로 확장되거나 축소될 때 유용합니다. JHipster는 여러 서비스 검색 옵션을 제공합니다:

1. **Consul (권장)**: Consul은 HashiCorp에서 개발한 멀티 데이터센터 지원을 포함한 서비스 메쉬 솔루션입니다. 서비스 검색, 헬스 체크, 키/값 저장, 멀티 데이터센터 지원 등의 기능을 제공합니다. JHipster에서 Consul을 권장하는 이유는 그 안정성과 확장성 때문입니다. Consul은 마이크로서비스 아키텍처를 위한 강력하고 유연한 솔루션을 제공합니다.

2. **JHipster Registry (레거시, Eureka 사용, Spring Cloud Config 지원 제공)**: JHipster Registry는 Netflix의 Eureka를 기반으로 하며, 서비스 검색과 함께 Spring Cloud Config를 통한 중앙 집중식 설정 관리 기능을 제공합니다. 이는 JHipster 생태계에서 오랜 시간 동안 사용되어 온 레거시 옵션이며, 여전히 유용한 기능을 많이 제공하지만, 새 프로젝트에서는 Consul이 권장됩니다.

3. **No service discovery (서비스 검색 없음)**: 서비스 검색 없이 마이크로서비스 아키텍처를 설정할 수도 있습니다. 이 옵션은 마이크로서비스 간의 의존성이 매우 제한적이거나, 또는 다른 방식으로 서비스 간의 통신을 관리할 계획이 있는 경우에 선택할 수 있습니다. 하지만, 서비스 검색을 사용하지 않는 경우 마이크로서비스 간의 통신과 관리가 복잡해질 수 있으므로 신중하게 고려해야 합니다.

각 옵션은 서로 다른 요구 사항과 선호도를 가진 프로젝트에 적합할 수 있으므로, 프로젝트의 요구 사항과 팀의 선호도를 고려하여 최적의 옵션을 선택해야 합니다. 

### JHipster에서 마이크로서비스 또는 모노리스 애플리케이션을 구성할 때, 인증 방식을 선택하는 것은 중요한 결정 중 하나입니다. JHipster는 주로 두 가지 인증 방식을 제공합니다:

1. **JWT 인증 (상태 비저장, 토큰 사용)**: JSON Web Token(JWT)을 사용하는 인증 방식은 상태를 서버 측에 저장하지 않고 클라이언트 측에서 토큰을 관리합니다. 이 토큰 안에 사용자의 인증 정보와 권한이 포함되며, API 요청마다 해당 토큰을 서버에 전송해 사용자가 인증되었는지 확인합니다. JWT 인증은 확장성이 뛰어나고 애플리케이션의 성능에 부담을 주지 않으며, 특히 분산 시스템이나 마이크로서비스 아키텍처에 적합합니다.

2. **OAuth 2.0 / OIDC 인증 (상태 저장, Keycloak 및 Okta와 함께 작동)**: OAuth 2.0은 외부 서비스(예: Keycloak, Okta)를 통해 인증을 처리하는 방식입니다. OpenID Connect(OIDC)는 OAuth 2.0을 기반으로 한 인증 레이어로, 사용자 인증을 위한 추가 기능을 제공합니다. 이 방식은 인증 정보를 서버 측에서 관리하며, 보다 강력한 보안과 유연성을 제공하지만, 구성과 관리가 복잡할 수 있습니다. 대규모 시스템이나 기업 환경에서 선호되는 방식입니다.

각 인증 방식은 그 특성과 장단점이 있으므로, 프로젝트의 요구 사항과 개발 및 운영 환경을 고려하여 적절한 방식을 선택해야 합니다. 예를 들어, 간단하게 시작하려는 경우나 마이크로서비스 아키텍처를 구축하려는 경우 JWT 인증을 고려할 수 있습니다. 반면, 기업 환경에서 복잡한 보안 요구 사항을 충족시켜야 하는 경우 OAuth 2.0/OIDC 인증을 고려할 수 있습니다. 

### JHipster는 애플리케이션의 성능과 확장성을 개선하기 위해 다양한 캐싱 옵션을 제공합니다. 여기서 선택할 수 있는 옵션들은 다음과 같습니다:

1. **No cache**: 이 옵션을 선택하면, SQL 데이터베이스를 사용할 때 Hibernate 2차 레벨 캐시가 비활성화됩니다. 캐싱이 없을 경우 데이터베이스와의 각 요청은 직접 처리되어야 하므로, 성능이 저하될 수 있습니다. 특히 읽기 작업이 많은 애플리케이션에서 성능 저하가 눈에 띄게 될 수 있습니다.

2. **Ehcache**: Ehcache는 로컬 캐시로, 단일 노드 환경에서 사용됩니다. 메모리 내 캐싱을 통해 데이터 액세스 속도를 빠르게 하여 성능을 향상시킬 수 있습니다. 단일 애플리케이션 인스턴스에서 운영될 때 적합한 옵션입니다.

3. **Caffeine**: Caffeine 역시 로컬 캐시로, 빠른 성능을 자랑합니다. Ehcache와 유사하게 단일 노드 환경에서 사용되며, 고성능 메모리 내 캐싱 라이브러리입니다. 최신 알고리즘을 사용하여 높은 처리량과 낮은 지연 시간을 제공합니다.

4. **Hazelcast**: Hazelcast는 분산 캐시로, 여러 노드에서 운영될 수 있습니다. 이는 클러스터 환경에서 데이터를 공유하고, 게이트웨이 애플리케이션에 대한 속도 제한 지원 같은 추가 기능을 제공합니다. 확장성이 요구되는 대규모 분산 시스템에 적합합니다.

5. **Infinispan**: Infinispan은 하이브리드 캐시로, 분산 캐시 기능과 함께 로컬 캐싱 옵션도 제공합니다. 여러 노드에서 운영되며, 데이터 그리드 기능을 통해 높은 확장성과 성능을 제공합니다. 대규모, 복잡한 환경에서의 사용에 적합합니다.

각 캐싱 옵션은 애플리케이션의 요구사항, 환경, 그리고 운영 규모에 따라 선택될 수 있습니다. 단일 인스턴스 애플리케이션의 경우 Ehcache나 Caffeine이 적합할 수 있으며, 분산 환경이나 높은 확장성이 요구되는 경우 Hazelcast나 Infinispan이 더 나은 선택일 수 있습니다. 


### JHipster 프로젝트 구성 완료

모든 설정이 완료되면 JHipster는 설정에 따라 애플리케이션을 생성합니다. 이제 개발을 시작할 수 있습니다. 생성된 프로젝트는 JHipster가 제공하는 많은 기능을 활용하여 개발을 더욱 빠르고 효율적으로 진행할 수 있도록 돕습니다. 
